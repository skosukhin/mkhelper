#!/usr/bin/env python
import sys

import argparse
import os

from parser import DependencyParser
from preprocessor import Preprocessor


def get_args():
    parser = argparse.ArgumentParser(
        description='Generates OUTPUT makefile containing dependencies of the '
                    'INPUT Fortran source file. Recognizes Fortran "include", '
                    '"use" and "module" statements, as well as preprocessor '
                    '"#include", "#if" and associated directives. Optionally '
                    'evaluates simple expressions used in "#if" and "#elif" '
                    'directives.')
    parser.add_argument('input',
                        metavar='INPUT',
                        help='input Fortran source file')
    parser.add_argument('output',
                        metavar='OUTPUT',
                        help='output makefile with detected dependencies')
    parser.add_argument('--compile-target',
                        help='target of the compilation rule as it will '
                             'appear in the generated makefile; normally '
                             'equals to the path to the object file that is '
                             'supposed to be generated as a result of '
                             'compilation (by default, equals to name of the '
                             'INPUT without directory prefix and with '
                             'extension replaced with ".o" by default)')
    parser.add_argument('--compile-src-prereq',
                        help='source file prerequisite of the compilation '
                             'rule as it will appear in the generated '
                             'makefile; normally (and by default) equals to '
                             'INPUT but, for example, can be set to all but '
                             'the directory-part of the INPUT if vpath '
                             'feature is used')
    parser.add_argument('--mod-file-ext',
                        default='mod',
                        help='filename extension (without leading dot) of '
                             'compiler-generated Fortran module files '
                             '(default: %(default)s)')
    parser.add_argument('--mod-file-upper',
                        choices=['yes', 'no'], default='no',
                        help='whether Fortran compiler-generated module files '
                             'have uppercase names (default: %(default)s)')
    parser.add_argument('--inc-order',
                        default='src,flg', metavar='ORDER_LIST',
                        help='directory search order of files included using '
                             'the Fortran "include" statement; ORDER_LIST is '
                             'an ordered comma-separated list of keywords, '
                             'the corresponding search paths of which are to '
                             'be searched in the given order. The recognized '
                             'keywords are: "cwd" (for the current working '
                             'directory), "flg" (for directories '
                             'specified with -I compiler flag), "src" (for '
                             'the directory containing the INPUT source '
                             'file), and "inc" (for the directory containing '
                             'the file with the Fortran "include" statement. '
                             '(default: %(default)s)')
    parser.add_argument('--inc-pp-order',
                        default='inc,flg', metavar='ORDER_LIST',
                        help='equivalent to the "--inc-order" option, '
                             'only for the preprocessor "#include" directive. '
                             '(default: %(default)s)')
    parser.add_argument('--inc-root',
                        default='', metavar='INC_ROOT',
                        help='add to OUTPUT only "include"/"#include" '
                             'dependencies found inside INC_ROOT and its '
                             'subdirectories; does not affect Fortran '
                             '"module"/"use" dependencies')
    parser.add_argument('--try-eval-pp-expr',
                        action='store_true',
                        help='enable evaluation of expressions that appear in '
                             'preprocessor directives "#if" and "#elif"; if '
                             'disabled (default) or evaluation fails, both '
                             'branches of the directives are included by the '
                             'preprocessing stage.')
    parser.add_argument('--external-mods',
                        default='',
                        help='comma-separated list of modules to be'
                             'ignored when creating a dependency file')
    parser.add_argument('--fc-def-flag',
                        metavar='FC_DEF_FLAG', default='-D',
                        help='compiler flag used for preprocessor macro '
                             'definition; only flags starting with a single '
                             'dash (-) are currently supported (default: '
                             '%(default)s)')
    parser.add_argument('--fc-mod-out-flag',
                        metavar='FC_MOD_OUT_FLAG', default='-J',
                        help='compiler flag used to specify the directory '
                             'where module files are saved; only flags '
                             'starting with a single dash (-) are currently '
                             'supported (default: %(default)s)')
    parser.add_argument('--debug',
                        action='store_true',
                        help='dump debug information to file OUTPUT.debug')
    parser.add_argument('sep',
                        metavar='-- $(FCFLAGS)',
                        help='actual flags to be used in compilation, i.e. '
                             '$(FFLAGS) or $(FCFLAGS), must be given at the '
                             'end of the command line following the double '
                             'dash separator (--); the program searches these '
                             'flags for (possibly multiple instances of) '
                             'FC_DEF_FLAG, FC_MOD_OUT_FLAG and -I; any values '
                             'found are used in the generation of OUTPUT (in '
                             'the case of FC_MOD_OUT_FLAG, only the last '
                             'value found is used.')

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    arg_list = sys.argv[1:]

    # Separate arguments of this program and Fortran compiler flags
    sep = '--'
    if sep in arg_list:
        s = arg_list.index(sep)
        fortdep_arg_list = arg_list[:s]
        compiler_arg_list = arg_list[s + 1:]
    else:
        fortdep_arg_list = arg_list
        compiler_arg_list = []

    # append empty argument to keep argparse happy
    # about the positional argument sep
    args = parser.parse_args(fortdep_arg_list + [''])

    if args.compile_target is None:
        args.compile_target = os.path.splitext(
            os.path.basename(args.input))[0] + '.o'

    if args.compile_src_prereq is None:
        args.compile_src_prereq = args.input

    args.mod_file_upper = args.mod_file_upper == 'yes'

    args.inc_order = [c for c in args.inc_order.lower().split(',') if c]
    args.inc_pp_order = [c for c in args.inc_pp_order.lower().split(',') if c]

    if args.inc_root:
        args.inc_root = os.path.abspath(args.inc_root)

    args.external_mods = set(
        [c for c in args.external_mods.lower().split(',') if c])

    # Split multichar fc-flags from their value
    # (e.g. '-Wp,DMACRO' -> ['-Wp,D', 'MACRO']),
    # so argparse would understand them.
    known_flags = set([args.fc_mod_out_flag, args.fc_def_flag])
    compiler_arg_list_buf = []
    for arg in compiler_arg_list:
        for flag in known_flags:
            if arg.startswith(flag) and arg != flag:
                compiler_arg_list_buf.append(flag)
                arg = arg[len(flag):]
                break
        compiler_arg_list_buf.append(arg)

    compiler_parser = argparse.ArgumentParser()
    compiler_parser.add_argument('-I', default=[],
                                 action='append', dest='inc_dirs')
    compiler_parser.add_argument(args.fc_mod_out_flag, default='.',
                                 action='store', dest='mod_out_dir')
    compiler_parser.add_argument(args.fc_def_flag, default=[],
                                 action='append', dest='macro_defs')

    compiler_parser.parse_known_args(compiler_arg_list_buf, namespace=args)

    return args


def build_mod_file_names(mods, mod_dir, mod_ext, to_upper):
    base_names = (map(lambda s: s.upper(), mods)
                  if to_upper else mods.__iter__())
    return map(lambda s: os.path.join(mod_dir, s + '.' + mod_ext), base_names)


def main():
    args = get_args()

    print('Generating %s...' % args.output)

    debug_file = open(args.output + '.debug', 'w') if args.debug else None

    if debug_file:
        debug_file.writelines([
            '# Python version: ', sys.version.replace('\n', ' '), '\n',
            '# Command:\n',
            '  ', '\n    '.join(sys.argv), '\n',
            '# Parsed arguments:\n ',
            '\n '.join(
                [k + '=' + str(v) for k, v in vars(args).items()]), '\n'])

    input_file_dir = os.path.dirname(args.input)

    pp = Preprocessor(open(args.input, 'r'), input_file_dir, args.debug)
    pp.inc_order = args.inc_pp_order
    pp.inc_root = args.inc_root
    pp.inc_flag_dirs = args.inc_dirs
    pp.try_eval_expr = args.try_eval_pp_expr

    for macro_def in args.macro_defs:
        pp.define_from_cmd_line(macro_def)

    parser = DependencyParser(pp, input_file_dir)
    parser.inc_order = args.inc_order
    parser.inc_root = args.inc_root
    parser.inc_flag_dirs = args.inc_dirs
    parser.external_mods = args.external_mods

    parser.parse()

    if debug_file:
        debug_file.writelines([
            '# Conditional preprocessor statements:\n ',
            '\n '.join([expr[:-1] + ' = ' + result
                        for expr, result in pp.if_expressions]), '\n'])
        debug_file.close()

    rule_dep_on_src = (args.compile_target + ' ' + args.output +
                       ' : ' + args.compile_src_prereq)
    included_files = pp.included_files | parser.included_files
    if included_files:
        rule_dep_on_src += ' ' + ' '.join(included_files)

    rules = [rule_dep_on_src + '\n']

    if parser.provided_modules:
        provided_mod_files = ' '.join(
            build_mod_file_names(parser.provided_modules,
                                 args.mod_out_dir,
                                 args.mod_file_ext,
                                 args.mod_file_upper))
        rules.append(provided_mod_files + ' : ' + args.compile_target + '\n')

    if parser.required_modules:
        required_mod_files = ' '.join(
            build_mod_file_names(parser.required_modules,
                                 args.mod_out_dir,
                                 args.mod_file_ext,
                                 args.mod_file_upper))
        rules.append(args.compile_target + ' : ' + required_mod_files + '\n')

    with open(args.output, 'w') as out:
        out.writelines(rules)


if __name__ == "__main__":
    main()
